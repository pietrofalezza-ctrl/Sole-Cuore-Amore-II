<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Sole, cuore e amore II</title>
  <meta name="theme-color" content="#0a0a0a">
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <style>
    :root { --bg:#0a0a0a; --fg:#f1f1f1; --mid:#9a9a9a; --shadow:0 0 0.6rem rgba(255,255,255,.08); }
    @font-face{
      font-family:"PressStart";
      src: local(""), url('https://fonts.gstatic.com/s/pressstart2p/v11/e3t4euO8T-267oIAQAu6jDQyK3nR.woff2') format('woff2');
      font-display:swap;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:PressStart,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;letter-spacing:.5px;}
    canvas{display:block;margin:0 auto;image-rendering:pixelated;box-shadow:var(--shadow);cursor:crosshair;}
    .wrap{max-width:900px;margin:0 auto;padding:18px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:10px;}
    .title{font-size:14px;text-transform:uppercase;color:var(--fg);}
    .right{display:flex;align-items:center;gap:10px}
    .instructions{font-size:10px;color:var(--mid);opacity:.85;}
    .mutebtn{font:inherit;font-size:10px;padding:8px 10px;border-radius:8px;background:#111;color:#fff;border:1px solid #fff3;cursor:pointer;}
    /* STATUS BAR fuori dal canvas */
    .statusbar{
      display:flex;justify-content:space-between;align-items:center;
      border:1px solid #fff2;padding:8px 12px;margin:0 auto 10px;max-width:680px;
      background:#0e0e0e;box-shadow:var(--shadow);
    }
    .hearts{display:flex;gap:6px;align-items:center}
    .hearts .low{animation:blink .9s steps(2,start) infinite}
    .stats{font-size:10px;color:var(--mid);display:flex;gap:14px;flex-wrap:wrap}
    @keyframes blink{50%{opacity:.35}}
    /* Touch pad */
    .touch-pad{position:fixed;inset:auto 0 12px 0;display:flex;justify-content:center;pointer-events:none}
    .pad{display:grid;grid-template-columns:repeat(3,56px);grid-template-rows:repeat(3,56px);gap:10px;opacity:.7;filter:grayscale(1);pointer-events:auto}
    .btn{border:1px solid #fff3;background:#111;color:#fff;border-radius:8px;display:flex;align-items:center;justify-content:center;user-select:none;touch-action:manipulation;box-shadow:var(--shadow)}
    .btn:active{transform:translateY(1px)} .btn span{opacity:.85}
    /* Overlay */
    .overlay{position:fixed;inset:0;background:radial-gradient(ellipse at 50% 40%,#1a1a1a 0%,#0a0a0a 60%,#000 100%);display:flex;align-items:center;justify-content:center;z-index:3;padding:24px;text-align:center;opacity:1;transition:opacity .45s ease;}
    .overlay.is-hidden{opacity:0;pointer-events:none}
    .overlay .card{border:1px solid #fff2;padding:26px;max-width:640px;box-shadow:var(--shadow);animation:scan 2.2s linear infinite;}
    @keyframes scan{0%{box-shadow:0 0 0.6rem rgba(255,255,255,.08),inset 0 -2px 0 rgba(255,255,255,.05);}50%{box-shadow:0 0 0.9rem rgba(255,255,255,.14),inset 0 -2px 0 rgba(255,255,255,.1);}100%{box-shadow:0 0 0.6rem rgba(255,255,255,.08),inset 0 -2px 0 rgba(255,255,255,.05);}}
    .overlay h1{font-size:18px;margin:0 0 16px}.overlay p{font-size:12px;line-height:1.6;color:var(--mid)}
    .overlay button{margin-top:14px;font-family:inherit;font-size:12px;padding:12px 16px;background:#111;color:#fff;border:1px solid #fff3;border-radius:8px;cursor:pointer;}
    .frame{border:2px solid #fff;outline:6px solid #000;padding:6px;margin:0 auto 12px;width:max-content;position:relative;}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">Sole, cuore e amore II</div>
      <div class="right">
        <div class="instructions">Usa la tastiera per muoverti</div>
        <button id="muteBtn" class="mutebtn" aria-pressed="false" title="Mute (M)">üîä Mute</button>
      </div>
    </header>

    <!-- STATUS BAR (fuori dal canvas) -->
    <div class="statusbar">
      <div class="hearts" id="heartsBar"></div>
      <div class="stats">
        <div id="regenTxt">Regen: 0.20/s</div>
        <div id="drainTxt">Sole: 0.50/s</div>
        <div id="collectedTxt">Cuori: 0</div>
        <div id="lvlTxt">Livello: 1</div>
        <div id="bestTxt"></div>
      </div>
    </div>

    <div class="frame">
      <canvas id="game" width="640" height="360" aria-label="Game canvas"></canvas>
    </div>
  </div>

  <div class="touch-pad" id="touchPad" aria-hidden="true">
    <div class="pad" role="group" aria-label="Pad direzionale">
      <div></div><button class="btn" data-dir="up" aria-label="Su"><span>‚ñ≤</span></button><div></div>
      <button class="btn" data-dir="left" aria-label="Sinistra"><span>‚óÑ</span></button><div></div>
      <button class="btn" data-dir="right" aria-label="Destra"><span>‚ñ∫</span></button>
      <div></div><button class="btn" data-dir="down" aria-label="Giu"><span>‚ñº</span></button><div></div>
    </div>
  </div>

  <!-- Overlays -->
  <div class="overlay" id="startOverlay" role="dialog" aria-modal="true">
    <div class="card">
      <h1>Lasciate ogni speranza voi che entrate</h1>
      <p>(clicca ‚ÄúEntra‚Äù o premi Invio per cominciare ‚Äî l‚Äôaudio partir√† dopo il consenso)</p>
      <button id="startBtn" type="button">Entra</button>
    </div>
  </div>

  <div class="overlay is-hidden" id="endOverlay" role="dialog" aria-modal="true">
    <div class="card" id="endCard">
      <h1 id="endTitle">Fine</h1>
      <p id="endMsg"></p>
      <div style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap;">
        <button id="nextBtn" type="button">Prossimo livello (N)</button>
        <button id="restartBtn" type="button">Ricomincia (R)</button>
      </div>
    </div>
  </div>

  <script>
  // PWA (attivo solo su HTTPS)
  if ('serviceWorker' in navigator && window.isSecureContext) { navigator.serviceWorker.register('sw.js').catch(()=>{}); }

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

// Responsive canvas scaling (keeps logical 640x360, scales CSS to fit screen)
function resizeCanvas(){
  const ratio = 16/9;
  // margins to account for header/status/touch UI
  const marginX = 24, marginY = 220;
  let w = Math.min(900, Math.max(320, window.innerWidth - marginX));
  let h = Math.max(240, window.innerHeight - marginY);
  if (w / h > ratio) w = h * ratio; else h = w / ratio;
  canvas.style.width = Math.floor(w) + 'px';
  canvas.style.height = Math.floor(h) + 'px';
}
window.addEventListener('resize', resizeCanvas, {passive:true});
resizeCanvas();


  let running = false;
  const player = { x: W/2, y: H/2, vx:0, vy:0, speed: 1.8, size: 10 };

  // Health & mechanics
  const healthMax = 5;
  let healthBase = 3, health = healthBase;
  let regenBase = 0.20, regenRate = regenBase;
  let sunDrainBase = 0.50, sunDrainRate = sunDrainBase; // pi√π dolce
  const regenPerHeart = 0.06, healPerHeart = 0.35;
  let collected = 0;
  let level = 1;
  let best = JSON.parse(localStorage.getItem('sca2-best') || '{"level":0,"time":0}');

  // Entities
  const hearts = [];
  let sun = null;
  const HEART_INTERVAL_MIN = 800, HEART_INTERVAL_MAX = 2200;
  let heartInterval = 2000, lastHeartSpawn = 0;
  const MAX_HEARTS = 16;
  const CRIT_CHANCE = 0.12;

  // Time
  let prevTs = 0, levelStart = 0, totalTime = 0;
  let winStableTimer = 0;
  const CRIT_GRACE_MS = 4000; // guarantee at least one crit heart early each level

  // Background
  const bgPattern = (() => {
    const c = document.createElement('canvas'); c.width = c.height = 8;
    const g = c.getContext('2d');
    g.fillStyle = '#0f0f0f'; g.fillRect(0,0,8,8);
    g.fillStyle = '#151515'; g.fillRect(0,0,4,4); g.fillRect(4,4,4,4);
    return ctx.createPattern(c, 'repeat');
  })();
  function drawGlow(x,y,r){
    const grd = ctx.createRadialGradient(x,y,1,x,y,r);
    grd.addColorStop(0,'rgba(255,255,255,0.14)'); grd.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }
  function drawBackground(){
    ctx.fillStyle = bgPattern; ctx.fillRect(0,0,W,H);
    drawGlow(W*0.2, H*0.35, 40);
    drawGlow(W*0.5, H*0.25, 26);
    drawGlow(W*0.8, H*0.50, 34);
  }

  // Sun
  function spawnSun(){ sun = { x: W*0.82, y: H*0.22, r: 18, t: 0 }; }
  function drawSun(){
    if(!sun) return;
    sun.t += 0.02;
    const pulse = 1 + Math.sin(sun.t)*0.05;
    const r = sun.r * pulse;
    const grd = ctx.createRadialGradient(sun.x, sun.y, 2, sun.x, sun.y, r*2.2);
    grd.addColorStop(0,'rgba(255,255,255,0.18)'); grd.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(sun.x, sun.y, r*2.2, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#f8f8f8'; ctx.beginPath(); ctx.arc(sun.x, sun.y, r, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
    for(let i=0;i<12;i++){
      const a = (i/12)*Math.PI*2 + sun.t*0.2;
      const x1 = sun.x + Math.cos(a)*(r+2), y1 = sun.y + Math.sin(a)*(r+2);
      const x2 = sun.x + Math.cos(a)*(r+7), y2 = sun.y + Math.sin(a)*(r+7);
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    }
  }

  // Hearts
  function spawnHeart(forceCrit=false){
    const margin = 16;
    const x = margin + Math.random()*(W - margin*2);
    const y = margin + Math.random()*(H - margin*2);
    const size = 8 + Math.floor(Math.random()*6);
    const crit = forceCrit ? true : (Math.random() < CRIT_CHANCE);
    hearts.push({x,y,size,crit});
    if(hearts.length>MAX_HEARTS) hearts.shift();
  }
  function drawHeart(x,y,s,fill='#f1f1f1', crit=false){
    if(crit){
      const grd = ctx.createRadialGradient(x,y,1,x,y,s*2.2);
      grd.addColorStop(0,'rgba(255,255,255,0.12)'); grd.addColorStop(1,'rgba(255,255,255,0)');
      ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(x,y,s*2.2,0,Math.PI*2); ctx.fill();
    }
    ctx.save(); ctx.translate(Math.round(x), Math.round(y)); ctx.fillStyle = fill;
    const p = s/6;
    ctx.beginPath();
    ctx.moveTo(0, p*2);
    ctx.bezierCurveTo(0, 0, -p*3, 0, -p*3, p*2);
    ctx.bezierCurveTo(-p*3, p*4, -p,  p*5.5, 0,  p*6);
    ctx.bezierCurveTo( p,  p*5.5, p*3, p*4,  p*3, p*2);
    ctx.bezierCurveTo( p*3, 0, 0, 0, 0, p*2);
    ctx.fill(); ctx.restore();
  }

  // Hearts bar (outside canvas)
  const heartsBar = document.getElementById('heartsBar');
  function renderHeartsBar(){
    heartsBar.innerHTML = '';
    let val = Math.max(0, Math.min(healthMax, health));
    for(let i=0;i<5;i++){
      let fill = 0;
      if(val >= 1){ fill = 1; val -= 1; }
      else if(val > 0){ fill = 0.5; val = 0; }
      const s = 12;
      const off = document.createElement('canvas'); off.width = s*2; off.height = s*2;
      const g = off.getContext('2d');
      // outline
      g.globalAlpha = 0.25;
      (function drawH(gx,gy){ 
        const p = s/6; g.beginPath(); g.moveTo(gx, gy+p*2);
        g.bezierCurveTo(gx, gy, gx-p*3, gy, gx-p*3, gy+p*2);
        g.bezierCurveTo(gx-p*3, gy+p*4, gx-p, gy+p*5.5, gx, gy+p*6);
        g.bezierCurveTo(gx+p, gy+p*5.5, gx+p*3, gy+p*4, gx+p*3, gy+p*2);
        g.bezierCurveTo(gx+p*3, gy, gx, gy, gx, gy+p*2); g.fillStyle = '#fff'; g.fill();
      })(off.width/2, off.height/2-2);
      g.globalAlpha = 1;
      if(fill > 0){
        g.save(); g.beginPath(); g.rect(0, 0, off.width * fill, off.height); g.clip();
        (function drawH(gx,gy){ 
          const p = s/6; g.beginPath(); g.moveTo(gx, gy+p*2);
          g.bezierCurveTo(gx, gy, gx-p*3, gy, gx-p*3, gy+p*2);
          g.bezierCurveTo(gx-p*3, gy+p*4, gx-p, gy+p*5.5, gx, gy+p*6);
          g.bezierCurveTo(gx+p, gy+p*5.5, gx+p*3, gy+p*4, gx+p*3, gy+p*2);
          g.bezierCurveTo(gx+p*3, gy, gx, gy, gx, gy+p*2); g.fillStyle = '#fff'; g.fill();
        })(off.width/2, off.height/2-2);
        g.restore();
      }
      const img = new Image(); img.src = off.toDataURL();
      const span = document.createElement('span'); span.appendChild(img);
      if(health < 1) span.className = 'low';
      heartsBar.appendChild(span);
    }
  }

  // Stats
  const regenTxt = document.getElementById('regenTxt');
  const drainTxt = document.getElementById('drainTxt');
  const collectedTxt = document.getElementById('collectedTxt');
  const lvlTxt = document.getElementById('lvlTxt');
  const bestTxt = document.getElementById('bestTxt');

  function renderStats(){
    regenTxt.textContent = `Regen: ${regenRate.toFixed(2)}/s`;
    drainTxt.textContent = `Sole: ${sunDrainRate.toFixed(2)}/s`;
    collectedTxt.textContent = `Cuori: ${collected}`;
    lvlTxt.textContent = `Livello: ${level}`;
    bestTxt.textContent = best.level ? `Record: L${best.level} ‚Ä¢ ${best.time.toFixed(1)}s` : '';
  }

  // Input
  const keys = {ArrowUp:0, ArrowDown:0, ArrowLeft:0, ArrowRight:0, w:0,a:0,s:0,d:0};
  addEventListener('keydown', e => { 
    if(!running && (e.key === 'Enter' || e.key === ' ')){ startGame(); e.preventDefault(); return; }
    if (e.key in keys){ keys[e.key]=1; e.preventDefault(); }
    if (e.key === 'm' || e.key === 'M') { toggleMute(); }
    if (e.key === 'r' || e.key === 'R') { if(endShown){ restart(); } }
    if (e.key === 'n' || e.key === 'N') { if(endShown && victoryShown){ nextLevel(); } }
  });
  addEventListener('keyup',   e => { if (e.key in keys){ keys[e.key]=0; e.preventDefault(); }});
  let mouseDown = false;
  function setDirFromMouse(evt){
    const rect = canvas.getBoundingClientRect();
    const cx = (evt.clientX - rect.left) * (canvas.width / rect.width);
    const cy = (evt.clientY - rect.top)  * (canvas.height / rect.height);
    const dx = cx - player.x, dy = cy - player.y;
    const len = Math.hypot(dx, dy) || 1;
    player.vx = (dx/len) * player.speed;
    player.vy = (dy/len) * player.speed;
  }
  canvas.addEventListener('mousedown', (e)=>{ if(!running){ return; } mouseDown = true; setDirFromMouse(e); });
  window.addEventListener('mouseup', ()=>{ mouseDown = false; player.vx = 0; player.vy = 0; });
  canvas.addEventListener('mousemove', (e)=>{ if(mouseDown){ setDirFromMouse(e); }});

  function bindPad(btn){
    const map = {up:'ArrowUp',down:'ArrowDown',left:'ArrowLeft',right:'ArrowRight'};
    const k = map[btn.dataset.dir];
    const press = (on)=>{ keys[k]=on?1:0; };
    btn.addEventListener('touchstart', e=>{ e.preventDefault(); press(true); }, {passive:false});
    btn.addEventListener('touchend',   e=>{ e.preventDefault(); press(false); }, {passive:false});
    btn.addEventListener('mousedown',  e=>{ e.preventDefault(); press(true); });
    btn.addEventListener('mouseup',    e=>{ e.preventDefault(); press(false); });
    btn.addEventListener('mouseleave', e=>{ press(false); });
  }
  document.querySelectorAll('.btn[data-dir]').forEach(bindPad);

  // Audio (loop continuo)
  let actx, masterGain, musicGain, sfxGain, musicStarted=false;
  async function ensureAudio(){
    if(!actx){
      actx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = actx.createGain(); masterGain.gain.value = 1; masterGain.connect(actx.destination);
      musicGain = actx.createGain(); musicGain.gain.value = 0.18; musicGain.connect(masterGain);
      sfxGain   = actx.createGain(); sfxGain.gain.value = 0.25; sfxGain.connect(masterGain);
    }
    if(actx.state === 'suspended'){ try{ await actx.resume(); }catch(e){} }
  }
  function toggleMute(){
    if(!masterGain) return;
    const btn = document.getElementById('muteBtn');
    const muted = masterGain.gain.value > 0 ? true : false;
    masterGain.gain.value = muted ? 0 : 1;
    btn.setAttribute('aria-pressed', (!muted).toString());
    btn.textContent = muted ? 'üîà Unmute' : 'üîä Mute';
  }
  document.getElementById('muteBtn').addEventListener('click', toggleMute);

  function sfxPickup(mult=1){
    if(!actx) return;
    const o = actx.createOscillator(); o.type='square'; o.frequency.value = 620*mult;
    const g = actx.createGain(); g.gain.value = 0.2;
    o.connect(g).connect(sfxGain);
    const t = actx.currentTime;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.2, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
    o.start(t); o.stop(t+0.2);
  }

  function startMusic(){
    if(musicStarted) return; musicStarted = true;
    const tempo = 54; // lento
    const beat = 60/tempo;
    const seqLen = 16;
    const schedule = () => {
      const now = actx.currentTime + 0.05;
      // Progressione evocativa Am‚ÄìF‚ÄìG‚ÄìC (voicing scuro), chiusura su Am
      const chords = [
        [57,60,64],[53,57,60],[55,59,62],[48,52,55]
      ];
      // Linea lead: intervalli e ritmo variati (minore), richiama il contorno emotivo del tema
      const lead = [69,69,72,71,69, 67,69,71,69, 69,71,72,74,72, 71,69,67];
      for(let rep=0; rep<2; rep++){
        for(let bar=0; bar<4; bar++){
          const chord = chords[bar];
          for(let step=0; step<seqLen; step++){
            const t = now + (rep*4*4 + bar*4 + step*(beat/2));
            const note = chord[step%3] - 12;
            blip(note, t, 0.25*beat, 0.33);
            const arp = chord[(step+(bar%2))%3] + ((step%4===0)?12:0);
            squarePad(arp, t, 0.4*beat, 0.11);
          }
        }
        // lead ogni ciclo
        for(let i=0;i<lead.length;i++){
          const t = now + rep*4*4 + i*beat*0.95;
          triangleLead(lead[i], t, 0.8*beat, 0.20);
        }
      }
      // rischedula per loop continuo
      setTimeout(schedule, (8*4*beat)*1000);
    };
    schedule();
  }
  function midiToFreq(m){ return 440 * Math.pow(2,(m-69)/12); }
  function env(node, t, dur, a=.01, d=.1, s=.6, r=.2){
    const g = actx.createGain(); node.connect(g); g.connect(musicGain);
    const end = t+dur+r;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(1, t+a);
    g.gain.linearRampToValueAtTime(s, t+a+d);
    g.gain.linearRampToValueAtTime(0.0001, end);
    return {g, end};
  }
  function blip(midi, t, dur, vol=0.5){
    const o = actx.createOscillator(); o.type='square'; o.frequency.setValueAtTime(midiToFreq(midi), t);
    const g = actx.createGain(); g.gain.value = vol;
    o.connect(g).connect(musicGain);
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(vol, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
    o.start(t); o.stop(t+dur+0.05);
  }
  function squarePad(midi, t, dur, vol=0.1){
    const o = actx.createOscillator(); o.type='square'; o.frequency.setValueAtTime(midiToFreq(midi), t);
    const filt = actx.createBiquadFilter(); filt.type='lowpass'; filt.frequency.setValueAtTime(1200, t);
    o.connect(filt);
    const e = env(filt, t, dur, .02, .2, .4, .3);
    o.start(t); o.stop(e.end);
  }
  function triangleLead(midi, t, dur, vol=0.2){
    const o = actx.createOscillator(); o.type='triangle'; o.frequency.setValueAtTime(midiToFreq(midi), t);
    const g = actx.createGain(); g.gain.value = vol;
    const vib = actx.createOscillator(); vib.frequency.value = 5.2;
    const vg = actx.createGain(); vg.gain.value = 6.5;
    vib.connect(vg).connect(o.frequency);
    o.connect(g).connect(musicGain);
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(vol, t+0.04);
    g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
    vib.start(t); o.start(t);
    o.stop(t+dur+0.05); vib.stop(t+dur+0.05);
  }

  // SFX speed blip
  let lastSpeed = 0;
  function sfxMove(){
    if(!actx) return;
    const speed = Math.hypot(player.vx, player.vy);
    if(speed>1.6 && lastSpeed<=1.0){
      const o = actx.createOscillator(); o.type='square'; o.frequency.value = 320;
      const g = actx.createGain(); g.gain.value = 0.15;
      o.connect(g).connect(sfxGain);
      g.gain.setValueAtTime(0, actx.currentTime);
      g.gain.linearRampToValueAtTime(0.15, actx.currentTime+0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, actx.currentTime+0.12);
      o.start(); o.stop(actx.currentTime+0.14);
    }
    lastSpeed = speed;
  }

  // Loop
  function step(ts){
    if(!running) return;
    if(!prevTs) prevTs = ts;
    const dt = Math.max(0.001, Math.min(0.05, (ts - prevTs)/1000));
    prevTs = ts;

    // intra-level difficulty growth (graduale)
    sunDrainRate += (0.004 + level*0.0015) * dt;
    heartInterval = Math.max(HEART_INTERVAL_MIN, 2000 - level*60);

    // spawn hearts
    if(!lastHeartSpawn) lastHeartSpawn = performance.now();
    if(performance.now() - lastHeartSpawn > heartInterval){
      spawnHeart(); lastHeartSpawn = performance.now();
    }
    // guarantee at least one critical heart in the first few seconds of each level
    const elapsedMs = performance.now() - levelStart;
    if (elapsedMs < CRIT_GRACE_MS && !hearts.some(h => h.crit) && hearts.length < MAX_HEARTS) {
      spawnHeart(true);
    }

    // movement
    const up = keys.ArrowUp||keys.w, dn=keys.ArrowDown||keys.s, lf=keys.ArrowLeft||keys.a, rt=keys.ArrowRight||keys.d;
    let ax = (rt?1:0) - (lf?1:0), ay = (dn?1:0) - (up?1:0);
    if(ax||ay){
      const len = Math.hypot(ax,ay); ax/=len; ay/=len;
      player.vx = ax*player.speed; player.vy = ay*player.speed;
    } else if(!mouseDown){
      player.vx *= 0.8; player.vy *= 0.8;
      if(Math.abs(player.vx)<.05) player.vx=0; if(Math.abs(player.vy)<.05) player.vy=0;
    }
    player.x = Math.max(player.size/2, Math.min(W-player.size/2, player.x + player.vx));
    player.y = Math.max(player.size/2, Math.min(H-player.size/2, player.y + player.vy));

    // collect hearts
    for(let i=hearts.length-1; i>=0; i--){
      const h = hearts[i];
      const dx = h.x - player.x, dy = h.y - player.y;
      if(Math.hypot(dx,dy) < (h.size + player.size)){
        hearts.splice(i,1); collected++;
        const mult = h.crit ? 3 : 1;
        regenRate += regenPerHeart * mult;
        health = Math.min(healthMax, health + healPerHeart * (h.crit ? 1.6 : 1));
        sfxPickup(h.crit ? 1.3 : 1);
      }
    }

    // update health
    health += (regenRate - sunDrainRate) * dt;
    health = Math.max(0, Math.min(healthMax, health));

    // draw
    drawBackground(); drawSun();
    for(const h of hearts) drawHeart(h.x, h.y, h.size, '#f1f1f1', h.crit);
    ctx.fillStyle = '#f1f1f1'; ctx.fillRect(Math.round(player.x - player.size/2), Math.round(player.y - player.size/2), player.size, player.size);
    ctx.strokeStyle = '#fff2'; ctx.strokeRect(0.5,0.5,W-1,H-1);

    // render UI (outside canvas)
    renderHeartsBar(); renderStats();

    // win/lose
    if(health <= 0){ showEnd(false); return; }
    if(regenRate > sunDrainRate){
      winStableTimer += dt;
      if(winStableTimer > 1.2){ showEnd(true); return; }
    } else { winStableTimer = 0; }

    requestAnimationFrame(step);
  }

  // Overlays & flow
  const startOverlay = document.getElementById('startOverlay');
  const endOverlay = document.getElementById('endOverlay');
  const endTitle = document.getElementById('endTitle');
  const endMsg = document.getElementById('endMsg');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const nextBtn = document.getElementById('nextBtn');
  let started = false, endShown = false, victoryShown = false;

  async function startGame(){
    if(started) return; started = true;
    startOverlay.classList.add('is-hidden');
    if (matchMedia('(max-width: 820px)').matches) document.getElementById('touchPad').removeAttribute('aria-hidden');
    await ensureAudio(); startMusic();
    // initial spawns
    for(let i=0;i<5;i++) spawnHeart();
    if(!sun) spawnSun();
    levelStart = performance.now();
    running = true; prevTs = 0; requestAnimationFrame(step);
  }
  function setBest(){
    const elapsed = (performance.now() - levelStart)/1000;
    totalTime += elapsed;
    if(level > (best.level||0) || (level === best.level && totalTime > (best.time||0))){
      best = {level, time: totalTime};
      localStorage.setItem('sca2-best', JSON.stringify(best));
    }
  }
  function showEnd(victory){
    endShown = true; running = false; victoryShown = victory;
    setBest();
    if(victory){
      endTitle.textContent = "Hai spezzato l'incantesimo";
      endMsg.textContent = "Il tuo respiro supera il morso del sole. Il livello si chiude.";
      nextBtn.style.display = 'inline-block';
    } else {
      endTitle.textContent = "Svanito nell'ombra";
      endMsg.textContent = "Il sole ti ha consumato. Raccogli pi√π cuori per aumentare il regen.";
      nextBtn.style.display = 'none';
    }
    endOverlay.classList.remove('is-hidden');
  }
  function restart(){
    endShown = false; victoryShown = false; running = false; started = false;
    // reset full run
    player.x = W/2; player.y = H/2; player.vx=0; player.vy=0;
    level = 1; totalTime = 0;
    regenRate = regenBase; sunDrainBase = 0.50; sunDrainRate = sunDrainBase; health = healthBase; collected = 0;
    hearts.length = 0; lastHeartSpawn = 0; winStableTimer = 0;
    endOverlay.classList.add('is-hidden'); startOverlay.classList.remove('is-hidden'); renderHeartsBar(); renderStats();
  }
  function nextLevel(){
    // scale difficulty (pi√π graduale)
    level += 1;
    sunDrainBase += 0.05 + level*0.008;
    sunDrainRate = sunDrainBase;
    regenRate = regenBase; health = healthBase; collected = 0;
    hearts.length = 0; lastHeartSpawn = 0; winStableTimer = 0;
    player.x = W/2; player.y = H/2; player.vx=0; player.vy=0;
    endOverlay.classList.add('is-hidden');
    levelStart = performance.now();
    running = true; requestAnimationFrame(step);
  }
  startBtn.addEventListener('click', startGame);
  restartBtn.addEventListener('click', restart);
  nextBtn.addEventListener('click', nextLevel);
  startOverlay.addEventListener('click', (e)=>{ if(e.target === startOverlay){ startGame(); } });

  // Idle render before start (music will start only after consent)
  (function idle(){
    if(!sun) spawnSun();
    if(hearts.length<4) spawnHeart();
    drawBackground(); drawSun();
    for(const h of hearts) drawHeart(h.x, h.y, h.size, '#f1f1f1', h.crit);
    ctx.fillStyle = '#f1f1f1'; ctx.fillRect(Math.round(player.x - player.size/2), Math.round(player.y - player.size/2), player.size, player.size);
    ctx.strokeStyle = '#fff2'; ctx.strokeRect(0.5,0.5,W-1,H-1);
    renderHeartsBar(); renderStats();
    requestAnimationFrame(idle);
  })();
  </script>
</body>
</html>
